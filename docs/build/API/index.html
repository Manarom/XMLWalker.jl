<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · XMLWalker.jl</title><meta name="title" content="API · XMLWalker.jl"/><meta property="og:title" content="API · XMLWalker.jl"/><meta property="twitter:title" content="API · XMLWalker.jl"/><meta name="description" content="Documentation for XMLWalker.jl."/><meta property="og:description" content="Documentation for XMLWalker.jl."/><meta property="twitter:description" content="Documentation for XMLWalker.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">XMLWalker.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Manarom/XMLWalker.jl/blob/(unknown)/docs/src/API.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="XMLWalker.jl-API"><a class="docs-heading-anchor" href="#XMLWalker.jl-API">XMLWalker.jl API</a><a id="XMLWalker.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#XMLWalker.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.ChainMatcher" href="#XMLWalker.ChainMatcher"><code>XMLWalker.ChainMatcher</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">    ChainMatcher</code></pre><p>Is a wrapper type for a vector of matchers, which is iterable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.ContainsAllPats" href="#XMLWalker.ContainsAllPats"><code>XMLWalker.ContainsAllPats</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">matcher  = ContainsAllPats(pat,field_name::Union{Symbol,Nothing}=nothing);</code></pre><p>matcher(input) - true if <code>input.field_name</code> contains all of pat elements (pat can be an iterable collection) if <code>field_name</code> is <code>nothing</code> than <code>input</code> itself is matched.</p><p>Other matchers: Union{XMLWalker.AnyPat, XMLWalker.ContainsAllPats, XMLWalker.ContainsAnyPat, XMLWalker.ContainsPat, XMLWalker.HasAllKeysPat, XMLWalker.HasAnyKeyPat, XMLWalker.MatchersSet, XMLWalker.MatchesPat, XMLWalker.PatContains}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L240-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.ContainsAnyPat" href="#XMLWalker.ContainsAnyPat"><code>XMLWalker.ContainsAnyPat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">matcher  = ContainsAnyPat(pat,field_name::Union{Symbol,Nothing}=nothing);</code></pre><p>matcher(input) - true if <code>input.field_name</code> contains any of pat elements (pat can be an iterable collection) if <code>field_name</code> is <code>nothing</code> than <code>input</code> itself is matched.</p><p>Other matchers: Union{XMLWalker.AnyPat, XMLWalker.ContainsAllPats, XMLWalker.ContainsAnyPat, XMLWalker.ContainsPat, XMLWalker.HasAllKeysPat, XMLWalker.HasAnyKeyPat, XMLWalker.MatchersSet, XMLWalker.MatchesPat, XMLWalker.PatContains}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L231-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.ContainsPat" href="#XMLWalker.ContainsPat"><code>XMLWalker.ContainsPat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">    matcher  = ContainsPat(pat,field_name::Union{Symbol,Nothing}=nothing);</code></pre><p>matcher(input) true if the <code>input.field_name</code> contains the pattern  <code>pat</code> if <code>field_name</code> is <code>nothing</code> than <code>input</code> itself is matched.</p><p>Other matchers: Union{XMLWalker.AnyPat, XMLWalker.ContainsAllPats, XMLWalker.ContainsAnyPat, XMLWalker.ContainsPat, XMLWalker.HasAllKeysPat, XMLWalker.HasAnyKeyPat, XMLWalker.MatchersSet, XMLWalker.MatchesPat, XMLWalker.PatContains}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L204-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.HasAllKeysPat" href="#XMLWalker.HasAllKeysPat"><code>XMLWalker.HasAllKeysPat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">    matcher  = ContainsPat(pat,field_name::Union{Symbol,Nothing}=nothing);</code></pre><p>matcher(input) - true if the <code>input.field_name</code> has all elements of <code>pat</code> as keys if <code>field_name</code> is <code>nothing</code> than <code>input</code> itself is matched.</p><p>Other matchers: Union{XMLWalker.AnyPat, XMLWalker.ContainsAllPats, XMLWalker.ContainsAnyPat, XMLWalker.ContainsPat, XMLWalker.HasAllKeysPat, XMLWalker.HasAnyKeyPat, XMLWalker.MatchersSet, XMLWalker.MatchesPat, XMLWalker.PatContains}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L222-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.HasAnyKeyPat" href="#XMLWalker.HasAnyKeyPat"><code>XMLWalker.HasAnyKeyPat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">    matcher  = ContainsPat(pat,field_name::Union{Symbol,Nothing}=nothing);</code></pre><p>matcher(input) - true if the<code>input.field_name</code> has at least one element of <code>pat</code> as a key if <code>field_name</code> is <code>nothing</code> than <code>input</code> itself is matched.</p><p>Other matchers: Union{XMLWalker.AnyPat, XMLWalker.ContainsAllPats, XMLWalker.ContainsAnyPat, XMLWalker.ContainsPat, XMLWalker.HasAllKeysPat, XMLWalker.HasAnyKeyPat, XMLWalker.MatchersSet, XMLWalker.MatchesPat, XMLWalker.PatContains}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L213-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.MatchersSet" href="#XMLWalker.MatchersSet"><code>XMLWalker.MatchersSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">matchers_set = MatchersSet(matchers_collection::P,type::Symbol) 
matchers_set_empty = MatchersSet(type::Symbol)</code></pre><p>Combines several matchers from <code>matchers_collection</code>,<code>type</code> can be <code>:all</code> or <code>:any</code> <code>matchers_set</code> is a callable object, it applies matchers from the collecion and  and if <code>type = :all</code> or <code>type = :any</code>  if all or any of matchers returns <code>true</code>. As far as <code>MatchersSet</code> is a subtype of <code>AbstractMatcher</code> it can be used as an input for <a href="#XMLWalker.find_nodes"><code>find_nodes(starting_node,::AbstractMatcher)</code></a> function to find nodes matching  the matchers set. Calling <code>MatchersSet</code> only <code>type</code> input creates an empty set, which can be filled with matchers using Base.push! function.</p><p>MatchersSet can be used to construct more complicated matchers than those provided by  parsing strings, for instance, it can be used to make matchers for multiple properties:</p><pre><code class="language-julia hljs">matchers_intersection = MatchersSet( (MatchesPat(&quot;A&quot;,:tag), MatchesPat(&quot;B&quot;,:variable), MatchesPat(&quot;C&quot;,:attributes)),:all)
find_nodes(starting_node, matchers_intersection) # will search for nodes, that contain &quot;A&quot;,&quot;B&quot; and &quot;C&quot; in their tag, variable and attributes fields simultaneously</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L136-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.MatchesPat" href="#XMLWalker.MatchesPat"><code>XMLWalker.MatchesPat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">matcher  = MatchesPat(pat,field_name::Union{Symbol,Nothing}=nothing);</code></pre><p>matcher(input) returns true if <code>pat</code> is matched to the <code>input</code> object field <code>field_name</code> if <code>field_name</code> is <code>nothing</code> than <code>input</code> itself is matched.</p><p>Other matchers: Union{XMLWalker.AnyPat, XMLWalker.ContainsAllPats, XMLWalker.ContainsAnyPat, XMLWalker.ContainsPat, XMLWalker.HasAllKeysPat, XMLWalker.HasAnyKeyPat, XMLWalker.MatchersSet, XMLWalker.MatchesPat, XMLWalker.PatContains}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L188-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.PatContains" href="#XMLWalker.PatContains"><code>XMLWalker.PatContains</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">    matcher  = PatContains(pat,field_name::Union{Symbol,Nothing}=nothing);</code></pre><p>matcher(input) - true if  <code>pat</code> contains the <code>input.field_name</code> if <code>field_name</code> is <code>nothing</code> than <code>input</code> itself is matched. Other matchers: Union{XMLWalker.AnyPat, XMLWalker.ContainsAllPats, XMLWalker.ContainsAnyPat, XMLWalker.ContainsPat, XMLWalker.HasAllKeysPat, XMLWalker.HasAnyKeyPat, XMLWalker.MatchersSet, XMLWalker.MatchesPat, XMLWalker.PatContains}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.chain_string_specification" href="#XMLWalker.chain_string_specification"><code>XMLWalker.chain_string_specification</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">Chain strings specification</code></pre><p><strong>Simple chain by tags</strong></p><p>A single string input (without the token separator symbol <code>&quot;/&quot;</code>) to the <code>XMLWalker.find_nodes</code> function, such as  <code>&quot;node1_tag&quot;</code>, represents a single token. By default, this token is assumed to be the tag field of the node and   <code>XMLWalker.find_nodes(&quot;node1_tag&quot;)</code> it finds all nodes (if any) matching the pattern specified by that string.  Additionally, the field name can be provided as an optional second input argument.</p><pre><code class="language-julia hljs">XMLWalker.find_nodes(starting_node, &quot;ABB&quot;,:attributes) # returns nodes, that has &quot;ABB&quot; value of field `attributes`  </code></pre><p>The symbol <code>&quot;/&quot;</code> is used as a token separator, indicating that all substrings separated by this symbol should be  interpreted as a sequence of matchings. Each token in the string corresponds to a node in the XML tree. The function  <code>XMLWalker.find_nodes</code> uses these chain-strings to create matchers that are checked sequentially, searching for   nodes that fit the entire sequence. For the chain-string <code>&quot;A/B/C&quot;</code>, <code>XMLWalker.find_nodes</code> returns nodes reachable   by following the path with tags <code>&quot;A&quot;</code> → <code>&quot;B&quot;</code> → <code>&quot;C&quot;</code>. </p><pre><code class="language-julia hljs">find_nodes(starting_node,&quot;A/B/C&quot;) # returns a vector of nodes which can be reached following the &quot;A&quot;-&gt;&quot;B&quot;-&gt;&quot;C&quot; chain 
# (starting_node must has a field :tag = &quot;A&quot;) </code></pre><p><strong>Single token specification</strong></p><p>The following sections describe a single token syntax, all of this is also applicable to the string-chain as far as  string-chain  is a sequance of tokens.</p><p><strong>Additional fields values check</strong></p><p>When a tag name is followed by a dot, as in <code>&quot;tag_name.field_name = field_value&quot;</code>, the <code>field_name</code> is interpreted as the name of the node&#39;s field, and the value after the <code>=</code> (i.e., <code>field_value</code>) is treated as the value of that field.  For example, <code>&quot;A.value = ABC&quot;</code> represents a node with the <code>tag</code> field equal to <code>&quot;A&quot;</code> and the <code>value</code> field equal to <code>&quot;ABC&quot;</code>.  By default, the value is parsed as a string, but if it can be interpreted as a number, such as in <code>&quot;tag_name.field_name = 25.4&quot;</code>, it means the <code>field_name</code> of the node tagged <code>tag_name</code> has the value <code>25.4</code> (Float64). Additionally, the annotation <code>::text</code>  can be added to force the value to be parsed as a string, so <code>/tag_name.field_name = 25.4::text/</code> searches for the <code>field_name</code>  with the string value <code>&quot;25.4&quot;</code>(String).</p><pre><code class="language-julia hljs">find_nodes(starting_node,&quot;B.value = 356::text&quot;) # searches for nodes with &quot;B&quot; tags and field value =&quot;356&quot;</code></pre><p><strong>Nodes with dictionary fields</strong></p><p>Node fields can also be of the <code>AbstractDict</code> type, allowing for searches of specific keys or key-value pairs. The syntax for this is as follows: <code>&quot;tag_name.field_name([key1,key2,key3])&quot;</code> when field name is followed by <code>&quot;(....)&quot;</code>. This pattern matches nodes where the <code>field_name</code> dictionary of a <code>tag_name</code> node contains any of the keys <code>&quot;key1&quot;</code>, <code>&quot;key2&quot;</code>, or <code>&quot;key3&quot;</code>. All keys must be enclosed in either <code>&quot;[]&quot;</code> or <code>&quot;{}&quot;</code>— where <code>&quot;[]&quot;</code> represents any of the keys, and <code>&quot;{}&quot;</code> means all keys must be present. For example, <code>&quot;A.attributes({p1,p2})&quot;</code> refers to a node with the tag <code>&quot;A&quot;</code> having the <code>attributes</code> field that contains both <code>&quot;p1&quot;</code> and <code>&quot;p2&quot;</code> keys.</p><p>It is also possible to search for nodes with specific key-value pairs within the field-dictionary. The syntax is similar to the key search pattern, but each key is followed by an equals sign (<code>=</code>). For instance, <code>&quot;tag_name.field_name({key1=value1,key2=value2})&quot;</code> matches a node with tag <code>&quot;tag_name&quot;</code> whose <code>field_name</code> dictionary contains both <code>&quot;key1&quot;=&gt;&quot;value1&quot;</code> and <code>&quot;key2&quot;=&gt;&quot;value2&quot;</code>.</p><pre><code class="language-julia hljs">find_nodes(starting_node,&quot;B.value([p1,p2])&quot;) # searches for nodes with &quot;B&quot; tags and field value with any of p1 or p2 keys
find_nodes(starting_node,&quot;B.value([p1=2,p2=20])&quot;) # searches for nodes with &quot;B&quot; tags and field value with all of &quot;p1&quot; =&gt; 2.0 and &quot;p2&quot; =&gt; 20.0 key-value pairs</code></pre><p><strong>Special Symbols</strong></p><p>All special symbols in this section apply to tags, field values, and field dictionary keys.</p><p><strong><code>&quot;[...]&quot;</code> (any) and <code>&quot;{...}&quot;</code> (all) Patterns</strong></p><p>To find nodes within a specific set of tags, for example <code>&quot;tg1&quot;</code>, <code>&quot;tg2&quot;</code>, or <code>&quot;tg3&quot;</code>, these tag names must be enclosed in square brackets <code>&quot;[]&quot;</code>. This pattern returns true if <strong>any</strong> of the enclosed tags match. For example, <code>&quot;[tg1,tg2,tg3]&quot;</code> searches for nodes with any of the tags <code>&quot;tg1&quot;</code>, <code>&quot;tg2&quot;</code>, or <code>&quot;tg3&quot;</code>. </p><p>Similarly, this pattern can be used to match field values, such as <code>&quot;A.field_name = [a,b]&quot;</code>, or to match field dictionary keys like <code>&quot;A.field_name([k1,k2])&quot;</code>.</p><pre><code class="language-julia hljs">find_nodes(starting_node,&quot;[A,B].field1 = [ab,bc]&quot;) # finds nodes with &quot;A&quot; or &quot;B&quot; tag field and &quot;ab&quot; or &quot;ac&quot; field1 field value </code></pre><p>If all patterns need to be matched simultaneously, the <code>{}</code> block can be used. This block is especially useful for specifying field values.  For example, <code>&quot;[A,B].field_name({a = 1, b = 2})&quot;</code> will match nodes tagged as <code>&quot;A&quot;</code> or <code>&quot;B&quot;</code> that contain both key-value pairs <code>&quot;a&quot; =&gt; 1.0</code> and <code>&quot;b&quot; =&gt; 2.0</code> in their <code>field_name</code> field.</p><p><strong><code>*</code> (always match), <code>*...</code> (contains) and <code>...::regex</code> (regular expression) patterns</strong></p><p>To skip a pattern node in a search tree, the <code>*</code> symbol, which represents an always-match wildcard, can be used. For example, <code>&quot;*.field_name = c&quot;</code> matches nodes with any tag and a <code>field_name</code> value of <code>&quot;c&quot;</code>. Hence, the <code>&quot;*.tag = A&quot;</code> token is equivalent to just <code>&quot;A&quot;</code>.</p><p>When the <code>*</code> symbol appears anywhere within a string, it indicates a partial match (i.e., the pattern is contained within the string). For instance, <code>&quot;*Prop&quot;</code> matches nodes with tags containing <code>&quot;Prop&quot;</code>, such as <code>&quot;BulkProp&quot;</code> or <code>&quot;PropertyOne&quot;</code>. This rule also applies to field values and dictionary keys. However, for key-value pairs matching, partial match patterns using <code>*</code> are not supported. If any key in the key-value pairs contains <code>*</code>, all values in that pair are ignored. For example, <code>&quot;A.field_name([*abb=1,b=2])&quot;</code> behaves the same as <code>&quot;A.field_name([*abb,b])&quot;</code>. Both field names and values in key-value pairs cannot contain the <code>*</code> symbol; thus, <code>&quot;node_tag.*partial_name = c&quot;</code> or <code>&quot;A.field_name([a=*b , b=2])&quot;</code> are not supported, but <code>&quot;node_tag.field_name = &quot;*ca&quot;</code> is allowed.</p><p>If the field value or key is marked with <code>&quot;::regex&quot;</code> it is interpreted as a regular expression, the main rule here is that thus marked pattern should be matched if julia <code>match(::Regex,str)</code> returns not <code>nothing</code>. To use regular expression for tag search it should be embraced in <code>{}</code> or <code>[]</code>. For instance, matcher string token for nodes containing digits in their tag field and attributes field dictionary with key <code>id</code> will be <code>&quot;[ [\d]::regex ].attributes([id])&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L541-L618">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.chain_string_to_matchers" href="#XMLWalker.chain_string_to_matchers"><code>XMLWalker.chain_string_to_matchers</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">chain_string_to_matchers(s::AbstractString,root_field_name::SymbolOrNothing=:tag)</code></pre><p>Converts chain string with multiple tokens to Matchers vector according to <a href="#XMLWalker.chain_string_specification"><code>chain_string_specification</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L265-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.chain_string_token_to_matcher" href="#XMLWalker.chain_string_token_to_matcher"><code>XMLWalker.chain_string_token_to_matcher</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">chain_string_token_to_matcher(s::String,field_name::SymbolOrNothing=DEFAULT_ROOT_TAG)</code></pre><p>Converts single token to a matcher object, for string specification see <a href="#XMLWalker.chain_string_specification"><code>chain_string_specification</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L443-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.convert_args_vector_to_regex_vector-Tuple{Any}" href="#XMLWalker.convert_args_vector_to_regex_vector-Tuple{Any}"><code>XMLWalker.convert_args_vector_to_regex_vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">convert_args_vector_to_regex_vector(input::AbstractVector)</code></pre><p>Converts the vector of args to regex, removes <code>*</code> and <code>::regex</code> if any</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L337-L342">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.convert_braced_arguments_to_matcher-Tuple{AbstractString, Union{Nothing, Symbol}}" href="#XMLWalker.convert_braced_arguments_to_matcher-Tuple{AbstractString, Union{Nothing, Symbol}}"><code>XMLWalker.convert_braced_arguments_to_matcher</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">convert_braced_arguments_to_matcher(args::AbstractString,field_name::SymbolOrNothing; as_keys::Bool=false)</code></pre><p>Input variables: args - string to be converted, e.g. &quot;{a,b,c}&quot; field<em>name - field name of the matcher  as</em>keys - if true all args are interpreted as keys of key-value pairs of <code>field_name</code> dictionary</p><p>Braced arguments like <code>{a,b,c}</code>, <code>[c,d,f]</code> are converted to matcher with the field name <code>field_name</code> <code>as_keys</code> flag means that arges are interpreted as elements contained in dictionary <code>field_name</code>, otherwise as  - values the field <code>field_name</code> should match itself.</p><pre><code class="language-julia hljs">struct A  tag end
matcher  = convert_braced_arguments_to_matcher(&quot;[a,b,c]&quot;,:tag,as_keys=false)
matcher(A(&quot;a&quot;)) # true
matcher(A([&quot;a&quot;,&quot;b&quot;])) # true

matcher  = convert_braced_arguments_to_matcher(&quot;[a,b,c]&quot;,:tag,as_keys=true)
matcher(A(Dict(&quot;a&quot;=&gt;1)))) # true

matcher  = convert_braced_arguments_to_matcher(&quot;[a=1,a=3]&quot;,:tag,as_keys=true)
matcher(A(Dict(&quot;a&quot;=&gt;2)))) # false because key-value doesnt matches  any  of `a=&gt;1.0` or `a=&gt;3`
</code></pre><p>If any of embraced patterns contain <code>::regex</code> or <code>*</code> symbol all of them are forced to be converted to regular expressions, if they are key-value pairs values are ignored</p><pre><code class="language-julia hljs">matcher  = convert_braced_arguments_to_matcher(&quot;[*a=1]&quot;,:tag,as_keys=true)

</code></pre><p>Returned matcher can be used to find nodes see <a href="#XMLWalker.find_nodes"><code>find_nodes</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L350-L383">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.extract_embraced_args_square_or_curl-Tuple{Any}" href="#XMLWalker.extract_embraced_args_square_or_curl-Tuple{Any}"><code>XMLWalker.extract_embraced_args_square_or_curl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">extract_embraced_args_square_or_curl(s;convert_to_regex::Bool=false)</code></pre><p>Switches embracer type  (<code>&quot;{..}&quot;</code> or <code>&quot;[...]&quot;</code>) from the string itself and retrurns the vector of parsed values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.extract_field-Tuple{Any}" href="#XMLWalker.extract_field-Tuple{Any}"><code>XMLWalker.extract_field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">extract_field(s)</code></pre><p>Returns right part of string  separated by non-digit dot <code>.</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/StringUtils.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.field_string_to_matcher-Tuple{AbstractString}" href="#XMLWalker.field_string_to_matcher-Tuple{AbstractString}"><code>XMLWalker.field_string_to_matcher</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">field_string_to_matcher(s::AbstractString)</code></pre><p>Converts field string to a single <code>&lt;:AbstractMatcher</code> object, field string can be <code>&quot;field_name = args1&quot;</code> or <code>&quot;field_name(args2)&quot;</code> In the first case, <code>args1</code> can be a single value number or string or regex-style object viz [a,b,c] or {a,b,c}, where <code>{}</code> or <code>[]</code>    braces tell that <code>all</code> or <code>any</code> args values viz &quot;a&quot;, &quot;b&quot; and &quot;c&quot; should be in <code>field_name</code> field. All <code>args1</code>  elements must be separated  by the comma  <code>,</code>.</p><p>In the second case <code>&quot;field_name(args1)&quot;</code>, the content of <code>(...)</code> is interpreted as arguments which are the members of AbstractDict stored in <code>field_name</code>, args2 must be embraced in <code>{}</code> or <code>[]</code>. E.g. <code>&quot;field_name([a,b,c] )&quot;</code> is interpreted as <code>any of keys &quot;a&quot;,&quot;b&quot;  and &quot;c&quot; must be among keys of</code>field<em>name<code>dictionary, when args1 also contains</code>=<code>, e.g.</code>args1 = [a=1,b=2,c=3]` this means key-value pairs specification, field</em>name({a=1,b=2,c=3}) means that <code>field_name</code> dictionary must contain the following  key-value pairs: <code>&quot;a&quot;=&gt;1,&quot;b&quot;=&gt;2,&quot;c&quot;=&gt;3</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L283-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.find_nodes" href="#XMLWalker.find_nodes"><code>XMLWalker.find_nodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">find_nodes(starting_node, search_string::AbstractString, field_name::SymbolOrNothing = DEFAULT_ROOT_TAG)</code></pre><p>First parses <code>search_string</code>, than finds nodes. For string specification see <a href="#XMLWalker.chain_string_specification"><code>chain_string_specification</code></a>. <code>field_name</code> is the root field name, by default it is a <code>tag</code> field. Root field name is the field,  where the first part of string token is searched, e.g.</p><pre><code class="language-julia hljs">find_nodes(starting_node, &quot;A.values = 5&quot;) # &quot;A&quot;  will be recursively searched in `starting_node.tag` and in all children nodes of `starting_node` etc.
find_nodes(starting_node, &quot;A.values = 5&quot;, :Name) # &quot;A&quot;  will be recursively searched in `starting_node.Name` and in all children nodes of `starting_node` etc.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L478-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.find_nodes!-Union{Tuple{T}, Tuple{Vector{T}, T, XMLWalker.AbstractMatcher}} where T" href="#XMLWalker.find_nodes!-Union{Tuple{T}, Tuple{Vector{T}, T, XMLWalker.AbstractMatcher}} where T"><code>XMLWalker.find_nodes!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">find_nodes!(node_vector::Vector{T},node::T,matcher::AbstractMatcher) where T</code></pre><p>Finds matching node and pushs it to the node_vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L465-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.find_nodes-Union{Tuple{T}, Tuple{T, XMLWalker.AbstractMatcher}} where T" href="#XMLWalker.find_nodes-Union{Tuple{T}, Tuple{T, XMLWalker.AbstractMatcher}} where T"><code>XMLWalker.find_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">find_nodes(starting_node::T, matcher::AbstractMatcher) where T</code></pre><p>Finds nodes, that match the matcher object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L496-L500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.find_nodes_chain!-Union{Tuple{T}, Tuple{Vector{T}, T, XMLWalker.ChainMatcher}, Tuple{Vector{T}, T, XMLWalker.ChainMatcher, Int64}, Tuple{Vector{T}, T, XMLWalker.ChainMatcher, Int64, Bool}} where T" href="#XMLWalker.find_nodes_chain!-Union{Tuple{T}, Tuple{Vector{T}, T, XMLWalker.ChainMatcher}, Tuple{Vector{T}, T, XMLWalker.ChainMatcher, Int64}, Tuple{Vector{T}, T, XMLWalker.ChainMatcher, Int64, Bool}} where T"><code>XMLWalker.find_nodes_chain!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">find_nodes_chain!(node_vector::Vector{T},node::T,tag_chain::ChainMatcher,state::Int=1,first_node::Bool=true) where T</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L515-L518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.find_nodes_chain-Union{Tuple{T}, Tuple{T, String}, Tuple{T, String, Union{Nothing, Symbol}}} where T" href="#XMLWalker.find_nodes_chain-Union{Tuple{T}, Tuple{T, String}, Tuple{T, String, Union{Nothing, Symbol}}} where T"><code>XMLWalker.find_nodes_chain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">find_nodes_chain(starting_node::T,xml_chain_string::String, field_name::SymbolOrNothing = DEFAULT_ROOT_TAG) where T</code></pre><p>Finds nodes chain, for details of xml<em>chain</em>string see <a href="#XMLWalker.chain_string_specification"><code>chain_string_specification</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L506-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.has_digit_dot-Tuple{AbstractString}" href="#XMLWalker.has_digit_dot-Tuple{AbstractString}"><code>XMLWalker.has_digit_dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">has_digit_dot(s::AbstractString)</code></pre><p>Checks for any dot symbol <code>.</code>, which is decimal digits separator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/StringUtils.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.has_nondigit_dot-Tuple{AbstractString}" href="#XMLWalker.has_nondigit_dot-Tuple{AbstractString}"><code>XMLWalker.has_nondigit_dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">has_nondigit_dot(s::AbstractString)</code></pre><p>Checks for any dot symbol <code>.</code>, which is not decimal digits separator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/StringUtils.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.single_string_or_number_to_matcher" href="#XMLWalker.single_string_or_number_to_matcher"><code>XMLWalker.single_string_or_number_to_matcher</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">single_string_or_number_to_matcher(value::AbstractString,field_name::SymbolOrNothing=:tag)</code></pre><p>Converts single string to matcher, this is a root function </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/XMLWalker.jl#L419-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.split_equality-Tuple{AbstractString}" href="#XMLWalker.split_equality-Tuple{AbstractString}"><code>XMLWalker.split_equality</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">split_equality(s::AbstractString)</code></pre><p>Splits string by first equality symbol <code>=</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/StringUtils.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XMLWalker.split_tag_and_field_name-Tuple{Any}" href="#XMLWalker.split_tag_and_field_name-Tuple{Any}"><code>XMLWalker.split_tag_and_field_name</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="nohighlight hljs">split_tag_and_field_name(s)</code></pre><p>Splits  string  into two parts by non-digit dot <code>.</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Manarom/XMLWalker.jl/blob/7c68bbd966c48fc7c14b53c02b3f9fc5de41cf93/src/StringUtils.jl#L59-L63">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 19 September 2025 16:11">Friday 19 September 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
